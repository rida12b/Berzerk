#!/usr/bin/env python3
"""
üéØ BERZERK BACKTESTER - Module de Validation de Performance
=====================================================

Ce module analyse les d√©cisions d'ACHAT stock√©es dans la base de donn√©es
et simule leur rentabilit√© pour valider la performance du syst√®me BERZERK.

Strat√©gie de test :
- P√©riode de d√©tention : 7 jours calendaires
- Prix d'achat : Ouverture du jour de bourse suivant la d√©cision
- Prix de vente : Ouverture du jour de bourse apr√®s 7 jours
- M√©triques calcul√©es : ROI, taux de r√©ussite, performance cumul√©e

Auteur : BERZERK System
Date : 2024-01-XX
"""

import json
import sqlite3
import sys
from datetime import datetime, timedelta

import yfinance as yf

# Configuration
HOLDING_PERIOD_DAYS = 7
DATABASE_PATH = "berzerk.db"


class BerzerkBacktester:
    """
    Classe principale pour le backtesting des d√©cisions BERZERK
    """

    def __init__(self, db_path: str = DATABASE_PATH):
        self.db_path = db_path
        self.results = []

    def get_buy_decisions(self) -> list[dict]:
        """
        R√©cup√®re toutes les d√©cisions d'ACHAT de la base de donn√©es
        """
        print("üîç Recherche des d√©cisions d'ACHAT dans la base de donn√©es...")

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # R√©cup√©rer tous les articles avec d√©cisions
        cursor.execute(
            """
            SELECT id, title, link, published_date, decision_json
            FROM articles
            WHERE decision_json IS NOT NULL
            AND status = "analyzed"
            ORDER BY published_date DESC
        """
        )

        rows = cursor.fetchall()
        conn.close()

        buy_decisions = []

        for row in rows:
            article_id, title, link, published_date, decision_json = row

            try:
                decision = json.loads(decision_json)

                # Nouveau format : chercher dans 'action'
                action = decision.get("action", "").upper()

                # V√©rifier si c'est une d√©cision d'ACHAT
                if action in ["ACHETER", "ACHAT", "BUY"]:
                    ticker = decision.get("ticker")

                    if ticker:  # Seulement si on a un ticker valide
                        buy_decisions.append(
                            {
                                "article_id": article_id,
                                "title": title,
                                "link": link,
                                "ticker": ticker,
                                "decision_date": datetime.fromisoformat(published_date),
                                "action": action,
                                "justification": decision.get(
                                    "justification", "Aucune justification"
                                ),
                                "allocation": decision.get(
                                    "allocation_pourcentage", 0.0
                                ),
                                "confiance": decision.get("confiance", "INCONNUE"),
                            }
                        )
                        print(
                            f"‚úÖ D√©cision d'ACHAT trouv√©e: {ticker} ({title[:30]}...)"
                        )
                    else:
                        print(f"‚ö†Ô∏è  D√©cision d'ACHAT sans ticker: {title[:30]}...")
                else:
                    print(f"üìä D√©cision {action}: {title[:30]}...")

            except json.JSONDecodeError as e:
                print(f"‚ùå Erreur JSON pour l'article {article_id}: {e}")
            except Exception as e:
                print(f"‚ùå Erreur lors du traitement de l'article {article_id}: {e}")

        print(f"\nüìà {len(buy_decisions)} d√©cision(s) d'ACHAT trouv√©e(s)")
        return buy_decisions

    def get_next_trading_day(self, date: datetime) -> datetime:
        """
        Trouve le prochain jour de bourse apr√®s une date donn√©e

        Args:
            date: Date de d√©part

        Returns:
            datetime: Prochain jour de bourse
        """
        # Commencer par le jour suivant
        next_day = date + timedelta(days=1)

        # √âviter les weekends (lundi = 0, dimanche = 6)
        while next_day.weekday() >= 5:  # 5 = samedi, 6 = dimanche
            next_day += timedelta(days=1)

        return next_day

    def simulate_trade(self, trade: dict) -> dict | None:
        """
        Simule un trade individuel avec la strat√©gie de d√©tention de 7 jours

        Args:
            trade: Dictionnaire contenant les infos du trade

        Returns:
            Dict: R√©sultat de la simulation ou None si erreur
        """
        ticker = trade["ticker"]
        decision_date = trade["decision_date"]

        print(
            f"üìä Simulation du trade {ticker} (d√©cision du {decision_date.strftime('%Y-%m-%d')})"
        )

        try:
            # Dates de trading avec ajustement pour les dates tr√®s r√©centes
            buy_date = self.get_next_trading_day(decision_date)
            sell_date = self.get_next_trading_day(
                buy_date + timedelta(days=HOLDING_PERIOD_DAYS)
            )

            # P√©riode de t√©l√©chargement des donn√©es avec marge √©tendue
            start_date = buy_date - timedelta(
                days=10
            )  # Plus de marge pour les dates r√©centes
            end_date = datetime.now() + timedelta(
                days=2
            )  # Utiliser date actuelle + marge

            print(
                f"   üìÖ P√©riode de donn√©es: {start_date.strftime('%Y-%m-%d')} ‚Üí {end_date.strftime('%Y-%m-%d')}"
            )

            # T√©l√©charger les donn√©es historiques
            stock = yf.Ticker(ticker)
            hist = stock.history(start=start_date, end=end_date)

            if hist.empty:
                print(f"‚ùå Pas de donn√©es historiques pour {ticker}")
                return None

            print(f"   üìä {len(hist)} jours de donn√©es r√©cup√©r√©s")

            # Trouver les prix d'achat et de vente
            buy_price = None
            sell_price = None
            actual_buy_date = None
            actual_sell_date = None

            # Prix d'achat : premier prix d'ouverture disponible >= buy_date
            for date, row in hist.iterrows():
                if date.date() >= buy_date.date():
                    buy_price = row["Open"]
                    actual_buy_date = date
                    print(
                        f"   üí∞ Prix d'achat trouv√©: {buy_price:.2f} USD le {date.strftime('%Y-%m-%d')}"
                    )
                    break

            # Si pas de prix d'achat exact, prendre le dernier prix disponible
            if buy_price is None:
                if not hist.empty:
                    last_row = hist.iloc[-1]
                    buy_price = last_row["Close"]  # Utiliser le prix de cl√¥ture
                    actual_buy_date = hist.index[-1]
                    print(
                        f"   üí∞ Prix d'achat (dernier disponible): {buy_price:.2f} USD le {actual_buy_date.strftime('%Y-%m-%d')}"
                    )
                else:
                    print(f"‚ùå Impossible de trouver un prix d'achat pour {ticker}")
                    return None

            # Prix de vente : chercher le prix apr√®s la p√©riode de d√©tention
            if datetime.now().date() < sell_date.date():
                # Si la date de vente est dans le futur, utiliser le prix actuel
                try:
                    current_info = stock.info
                    sell_price = current_info.get("regularMarketPrice", buy_price)
                    actual_sell_date = datetime.now()
                    print(
                        f"   üìà Prix de vente (actuel): {sell_price:.2f} USD le {actual_sell_date.strftime('%Y-%m-%d')}"
                    )
                except Exception:
                    # Si pas d'info actuelle, utiliser le dernier prix historique
                    sell_price = hist.iloc[-1]["Close"]
                    actual_sell_date = hist.index[-1]
                    print(
                        f"   üìà Prix de vente (dernier historique): {sell_price:.2f} USD le {actual_sell_date.strftime('%Y-%m-%d')}"
                    )
            else:
                # Prix de vente normal : chercher dans l'historique
                for date, row in hist.iterrows():
                    if date.date() >= sell_date.date():
                        sell_price = row["Open"]
                        actual_sell_date = date
                        print(
                            f"   üìà Prix de vente trouv√©: {sell_price:.2f} USD le {date.strftime('%Y-%m-%d')}"
                        )
                        break

                # Si pas trouv√©, utiliser le dernier prix disponible
                if sell_price is None:
                    sell_price = hist.iloc[-1]["Close"]
                    actual_sell_date = hist.index[-1]
                    print(
                        f"   üìà Prix de vente (dernier disponible): {sell_price:.2f} USD le {actual_sell_date.strftime('%Y-%m-%d')}"
                    )

            if buy_price is None or sell_price is None:
                print(f"‚ùå Impossible de trouver les prix pour {ticker}")
                return None

            # Calculer la performance
            roi_percent = ((sell_price - buy_price) / buy_price) * 100

            result = {
                "ticker": ticker,
                "title": (
                    trade["title"][:50] + "..."
                    if len(trade["title"]) > 50
                    else trade["title"]
                ),
                "decision_date": decision_date,
                "buy_date": actual_buy_date,
                "sell_date": actual_sell_date,
                "buy_price": round(buy_price, 2),
                "sell_price": round(sell_price, 2),
                "roi_percent": round(roi_percent, 2),
                "allocation": trade["allocation"],
                "is_profitable": roi_percent > 0,
                "is_partial_simulation": datetime.now().date()
                < sell_date.date(),  # Indicateur si simulation partielle
            }

            status = "‚úÖ PROFIT" if roi_percent > 0 else "‚ùå PERTE"
            partial_note = (
                " (‚ö†Ô∏è Simulation partielle)" if result["is_partial_simulation"] else ""
            )
            print(f"üíπ {ticker}: {roi_percent:+.2f}% {status}{partial_note}")

            return result

        except Exception as e:
            print(f"‚ùå Erreur simulation {ticker}: {e}")
            return None

    def run_backtest(self) -> dict:
        """
        Ex√©cute le backtest complet et g√©n√®re le rapport de performance

        Returns:
            Dict: R√©sultats complets du backtest
        """
        print("üöÄ D√âMARRAGE DU BACKTEST BERZERK")
        print("=" * 60)

        # √âtape 1 : Extraire les d√©cisions d'ACHAT
        buy_decisions = self.get_buy_decisions()

        if not buy_decisions:
            print("‚ùå Aucune d√©cision d'ACHAT trouv√©e dans la base de donn√©es")
            return {"error": "No buy decisions found"}

        # √âtape 2 : Simuler chaque trade
        print(f"\nüéØ Simulation de {len(buy_decisions)} trades...")
        print("-" * 60)

        successful_trades = []
        failed_trades = []

        for trade in buy_decisions:
            result = self.simulate_trade(trade)
            if result:
                successful_trades.append(result)
            else:
                failed_trades.append(trade)

        # √âtape 3 : Calculer les m√©triques
        if not successful_trades:
            print("‚ùå Aucun trade n'a pu √™tre simul√©")
            return {"error": "No successful simulations"}

        # M√©triques de performance
        total_trades = len(successful_trades)
        winning_trades = [t for t in successful_trades if t["is_profitable"]]
        losing_trades = [t for t in successful_trades if not t["is_profitable"]]

        win_rate = (len(winning_trades) / total_trades) * 100
        avg_roi = sum(t["roi_percent"] for t in successful_trades) / total_trades
        total_roi = sum(t["roi_percent"] for t in successful_trades)

        best_trade = max(successful_trades, key=lambda x: x["roi_percent"])
        worst_trade = min(successful_trades, key=lambda x: x["roi_percent"])

        # Stocker les r√©sultats
        self.results = successful_trades

        return {
            "total_trades": total_trades,
            "successful_simulations": len(successful_trades),
            "failed_simulations": len(failed_trades),
            "winning_trades": len(winning_trades),
            "losing_trades": len(losing_trades),
            "win_rate": round(win_rate, 2),
            "avg_roi": round(avg_roi, 2),
            "total_roi": round(total_roi, 2),
            "best_trade": best_trade,
            "worst_trade": worst_trade,
            "trades": successful_trades,
        }

    def display_results(self, results: dict):
        """
        Affiche le rapport de performance format√©

        Args:
            results: R√©sultats du backtest
        """
        if "error" in results:
            print(f"‚ùå Erreur : {results['error']}")
            return

        print("\n" + "=" * 60)
        print("üìà RAPPORT DE PERFORMANCE BERZERK")
        print("=" * 60)

        # Statistiques globales
        print("\nüìä STATISTIQUES GLOBALES")
        print("-" * 30)
        print(f"Total des trades simul√©s    : {results['total_trades']}")
        print(f"Simulations r√©ussies       : {results['successful_simulations']}")
        print(f"Simulations √©chou√©es       : {results['failed_simulations']}")
        print(f"Trades gagnants            : {results['winning_trades']}")
        print(f"Trades perdants            : {results['losing_trades']}")
        print(f"Taux de r√©ussite           : {results['win_rate']:.2f}%")
        print(f"ROI moyen par trade        : {results['avg_roi']:+.2f}%")
        print(f"ROI total cumul√©           : {results['total_roi']:+.2f}%")

        # Meilleurs et pires trades
        print("\nüèÜ MEILLEUR TRADE")
        print("-" * 20)
        best = results["best_trade"]
        print(f"Ticker  : {best['ticker']}")
        print(f"ROI     : {best['roi_percent']:+.2f}%")
        print(
            f"Achat   : {best['buy_price']:.2f} USD le {best['buy_date'].strftime('%Y-%m-%d')}"
        )
        print(
            f"Vente   : {best['sell_price']:.2f} USD le {best['sell_date'].strftime('%Y-%m-%d')}"
        )

        print("\nüìâ PIRE TRADE")
        print("-" * 15)
        worst = results["worst_trade"]
        print(f"Ticker  : {worst['ticker']}")
        print(f"ROI     : {worst['roi_percent']:+.2f}%")
        print(
            f"Achat   : {worst['buy_price']:.2f} USD le {worst['buy_date'].strftime('%Y-%m-%d')}"
        )
        print(
            f"Vente   : {worst['sell_price']:.2f} USD le {worst['sell_date'].strftime('%Y-%m-%d')}"
        )

        # D√©tail de tous les trades
        print("\nüìã D√âTAIL DE TOUS LES TRADES")
        print("-" * 40)
        for trade in results["trades"]:
            status = "‚úÖ" if trade["is_profitable"] else "‚ùå"
            print(
                f"{status} {trade['ticker']:<6} | {trade['roi_percent']:+6.2f}% | "
                f"{trade['buy_date'].strftime('%Y-%m-%d')} ‚Üí {trade['sell_date'].strftime('%Y-%m-%d')} | "
                f"{trade['title']}"
            )

        # Conclusions
        print("\nüéØ CONCLUSIONS")
        print("-" * 15)
        if results["win_rate"] > 60:
            print(
                "üî• Performance EXCELLENTE ! Le syst√®me montre une tr√®s bonne capacit√© pr√©dictive."
            )
        elif results["win_rate"] > 50:
            print("üëç Performance POSITIVE. Le syst√®me bat le hasard.")
        else:
            print("‚ö†Ô∏è  Performance √Ä AM√âLIORER. Revoir les strat√©gies d'analyse.")

        if results["avg_roi"] > 2:
            print("üí∞ ROI moyen tr√®s attractif pour une strat√©gie √† 7 jours.")
        elif results["avg_roi"] > 0:
            print("üìà ROI moyen positif, strat√©gie rentable.")
        else:
            print("üìâ ROI moyen n√©gatif, n√©cessite des ajustements.")


def main():
    """
    Fonction principale du backtester
    """
    print("üéØ BERZERK BACKTESTER - Validation de Performance")
    print("=" * 60)

    # V√©rifier les pr√©requis
    import importlib.util

    missing_modules = []
    for module in ["pandas", "yfinance"]:
        if importlib.util.find_spec(module) is None:
            missing_modules.append(module)

    if missing_modules:
        print(f"‚ùå Erreur : Modules manquants {missing_modules}")
        print("üí° Installez les d√©pendances : pip install yfinance pandas")
        sys.exit(1)

    # Lancer le backtester
    backtester = BerzerkBacktester()
    results = backtester.run_backtest()
    backtester.display_results(results)

    print(f"\nüîÑ Backtest termin√© ! P√©riode test√©e : {HOLDING_PERIOD_DAYS} jours")
    print("üìä Utilisez ces r√©sultats pour am√©liorer les strat√©gies BERZERK.")


if __name__ == "__main__":
    main()
