"""
Orchestrateur Automatis√© BERZERK - Phase 2.3
============================================

Ce module contient le pipeline automatis√© complet utilisant LangGraph pour orchestrer
l'ensemble de la cha√Æne d'analyse financi√®re : de la news brute √† la d√©cision d'investissement.

Architecture : News ‚Üí Analyse Initiale ‚Üí Routage Agents ‚Üí Analyses Sp√©cialis√©es ‚Üí D√©cision Finale

Auteur: BERZERK Team
Phase: 2.3 - Automatisation Compl√®te
"""

import json
import sys
from typing import Dict, List, Any, TypedDict
from datetime import datetime

# LangGraph Imports
from langgraph.graph import StateGraph, END
from langchain_core.output_parsers import JsonOutputParser

# Imports depuis nos modules existants
from berzerk_lab import get_article_text, analyze_news_with_llm
from agents import (
    route_to_agents, run_agent_analysis, run_ticker_hunter, 
    run_augmented_analysis, # Garde pour flexibilit√©
    run_pure_prediction_analysis, # NOUVEAU : Agent de pr√©diction pure
    AGENT_PROFILES, llm
)

# --- D√âFINITION DE L'√âTAT DU GRAPHE ---

class GraphState(TypedDict):
    """√âtat qui circule dans le graphe et est mis √† jour √† chaque √©tape."""
    news_link: str
    news_summary: str
    full_article_text: str
    initial_analysis: Dict[str, Any]
    actionable_tickers: List[Dict[str, str]]  # Nouveau : R√©sultat du Ticker Hunter
    agent_team: List[Dict[str, str]]
    agent_debriefing: str
    final_decision: Dict[str, Any]
    capital_disponible: float
    execution_log: List[str]
    timestamp: str

# --- MOD√àLE PYDANTIC POUR LA D√âCISION FINALE ---

from pydantic import BaseModel, Field

class InvestmentDecision(BaseModel):
    """Mod√®le pour valider la d√©cision finale d'investissement."""
    decision: str = Field(description="ACHETER, VENDRE, SURVEILLER ou IGNORER")
    ticker: str = Field(description="Ticker de l'action concern√©e ou null")
    confiance: str = Field(description="√âLEV√âE, MOYENNE ou FAIBLE")
    horizon: str = Field(description="Court Terme, Moyen Terme, ou Long Terme")
    justification_synthetique: str = Field(description="Justification en une phrase")
    allocation_capital_pourcentage: float = Field(description="Pourcentage du capital √† allouer (0.0 √† 5.0)")
    points_cles_positifs: List[str] = Field(description="Points positifs cl√©s")
    points_cles_negatifs_risques: List[str] = Field(description="Risques identifi√©s")

# --- FONCTIONS UTILITAIRES ---

def log_step(state: GraphState, message: str) -> None:
    """Ajoute un log √† l'√©tat avec timestamp."""
    timestamp = datetime.now().strftime("%H:%M:%S")
    log_message = f"[{timestamp}] {message}"
    state["execution_log"].append(log_message)
    print(f"üîÑ {log_message}")

def format_debriefing(agent_analyses: List[Dict[str, str]]) -> str:
    """Formate les analyses des agents pour le superviseur."""
    debriefing_parts = []
    for i, analysis in enumerate(agent_analyses, 1):
        debriefing_parts.append(
            f"\n--- ANALYSE {i} : {analysis['agent_type'].upper().replace('_', ' ')} ---\n"
            f"Focus : {analysis['focus']}\n\n"
            f"{analysis['analysis']}\n"
            f"{'='*80}"
        )
    return "\n".join(debriefing_parts)

# --- N≈íUDS DU GRAPHE (chaque n≈ìud est une fonction) ---

def node_initial_analysis(state: GraphState) -> GraphState:
    """N≈ìud 1 : R√©cup√®re le texte de l'article et fait l'analyse initiale."""
    log_step(state, "D√âMARRAGE - Analyse Initiale")
    
    try:
        # R√©cup√©ration du texte complet
        full_text = get_article_text(state['news_link'])
        if not full_text:
            raise ValueError("Impossible de r√©cup√©rer le texte de l'article")
        
        # Analyse initiale avec LLM
        analysis = analyze_news_with_llm(full_text)
        if not analysis:
            raise ValueError("√âchec de l'analyse initiale")
        
        # Mise √† jour de l'√©tat
        state['full_article_text'] = full_text
        state['initial_analysis'] = analysis
        state['news_summary'] = analysis.get('resume', '')
        
        log_step(state, f"‚úÖ Analyse initiale termin√©e - Impact: {analysis.get('impact', 'N/A')}/10")
        log_step(state, f"‚úÖ Entit√©s d√©tect√©es: {', '.join(analysis.get('entites', []))}")
        
    except Exception as e:
        log_step(state, f"‚ùå ERREUR dans l'analyse initiale: {str(e)}")
        state['initial_analysis'] = {"error": str(e)}
    
    return state

def node_find_actionable_tickers(state: GraphState) -> GraphState:
    """N≈ìud 2 : Chasse aux Tickers - Identifie les tickers actionnables."""
    log_step(state, "TICKER HUNTER - Identification des tickers actionnables")
    
    try:
        if 'error' in state['initial_analysis']:
            raise ValueError("Analyse initiale √©chou√©e, impossible d'identifier les tickers")
        
        # Ex√©cution du Ticker Hunter
        ticker_result = run_ticker_hunter(
            news_summary=state['news_summary'],
            full_article_text=state['full_article_text']
        )
        
        actionable_tickers = ticker_result.get('tickers_identifies', [])
        state['actionable_tickers'] = actionable_tickers
        
        if actionable_tickers:
            log_step(state, f"üéØ {len(actionable_tickers)} ticker(s) actionnable(s) identifi√©(s)")
            for ticker_info in actionable_tickers:
                # Gestion des objets Pydantic ET des dictionnaires
                if hasattr(ticker_info, 'ticker'):
                    ticker = ticker_info.ticker
                    company = ticker_info.nom_entreprise
                else:
                    ticker = ticker_info.get('ticker', 'N/A')
                    company = ticker_info.get('nom_entreprise', 'N/A')
                log_step(state, f"   ‚Üí {ticker} ({company})")
        else:
            log_step(state, "‚ö†Ô∏è  Aucun ticker actionnable identifi√© - Pipeline orient√© macro")
            
    except Exception as e:
        log_step(state, f"‚ùå ERREUR dans le Ticker Hunter: {str(e)}")
        state['actionable_tickers'] = []
    
    return state

def node_route_to_agents(state: GraphState) -> GraphState:
    """N≈ìud 3 : Recrute l'√©quipe d'agents bas√©e sur les tickers identifi√©s."""
    log_step(state, "ROUTAGE - Recrutement de l'√©quipe d'agents (bas√© sur tickers)")
    
    try:
        if 'error' in state['initial_analysis']:
            raise ValueError("Analyse initiale √©chou√©e, impossible de router")
        
        actionable_tickers = state.get('actionable_tickers', [])
        
        if actionable_tickers:
            # Mode PR√âCIS : Tickers identifi√©s ‚Üí Agents cibl√©s
            team = []
            
            # Pour chaque ticker, on cr√©e un analyste d'actions d√©di√©
            for ticker_info in actionable_tickers:
                # Gestion des objets Pydantic ET des dictionnaires
                if hasattr(ticker_info, 'ticker'):
                    ticker = ticker_info.ticker
                    company = ticker_info.nom_entreprise
                else:
                    ticker = ticker_info.get('ticker', '')
                    company = ticker_info.get('nom_entreprise', '')
                
                team.append({
                    "agent_type": "analyste_actions",
                    "focus": f"{ticker} ({company})"
                })
            
            # Ajout d'un analyste sectoriel si multiple tickers
            if len(actionable_tickers) > 1:
                sectors = []
                for ticker_info in actionable_tickers:
                    # Gestion des objets Pydantic ET des dictionnaires
                    if hasattr(ticker_info, 'justification_impact'):
                        justification = ticker_info.justification_impact
                    else:
                        justification = ticker_info.get('justification_impact', '')
                    # Extraction de mots-cl√©s sectoriels basiques
                    if any(word in justification.lower() for word in ['tech', 'technologie', 'intelligence artificielle', 'ia']):
                        sectors.append('Technologie')
                    elif any(word in justification.lower() for word in ['auto', 'v√©hicule', 'transport']):
                        sectors.append('Automobile')
                    elif any(word in justification.lower() for word in ['√©nergie', 'p√©trole', 'gaz']):
                        sectors.append('√ânergie')
                    elif any(word in justification.lower() for word in ['finance', 'banque', 'cr√©dit']):
                        sectors.append('Finance')
                
                if sectors:
                    unique_sectors = list(set(sectors))
                    team.append({
                        "agent_type": "analyste_sectoriel",
                        "focus": f"Impact sectoriel sur {', '.join(unique_sectors)}"
                    })
            
            log_step(state, f"üéØ Mode PR√âCIS activ√© - {len(actionable_tickers)} ticker(s) cibl√©(s)")
            
        else:
            # Mode FALLBACK : Analyse macro classique
            entities = state['initial_analysis'].get('entites', [])
            team = route_to_agents(entities, state['news_summary'])
            log_step(state, "‚ö†Ô∏è Mode FALLBACK - Pas de tickers, analyse macro")
        
        if not team:
            raise ValueError("Aucun agent recrut√© par le routeur")
        
        state['agent_team'] = team
        
        log_step(state, f"‚úÖ √âquipe recrut√©e: {len(team)} agent(s)")
        for agent in team:
            log_step(state, f"   - {agent['agent_type']} ‚Üí Focus: {agent['focus']}")
            
    except Exception as e:
        log_step(state, f"‚ùå ERREUR dans le routage: {str(e)}")
        state['agent_team'] = []
    
    return state

def node_run_agent_analyses(state: GraphState) -> GraphState:
    """N≈ìud 4 : Ex√©cute les analyses de chaque agent sp√©cialis√© (mode PURE PREDICTION)."""
    log_step(state, "EX√âCUTION - Analyses sp√©cialis√©es PURE PREDICTION (mode 'tac au tac')")
    
    try:
        if not state['agent_team']:
            raise ValueError("Aucun agent disponible pour l'analyse")
        
        agent_analyses = []
        actionable_tickers = state.get('actionable_tickers', [])
        
        for i, agent in enumerate(state['agent_team'], 1):
            log_step(state, f"Ex√©cution agent {i}/{len(state['agent_team'])}: {agent['agent_type']}")
            
            # D√©tecter si c'est un agent d'analyse d'actions avec ticker identifi√©
            is_ticker_analysis = (
                agent['agent_type'] == 'analyste_actions' and 
                actionable_tickers and 
                len(actionable_tickers) > 0
            )
            
            if is_ticker_analysis:
                # Extraire le ticker du focus (format: "AAPL (Apple Inc.)")
                focus_text = agent['focus']
                ticker = None
                
                # Chercher le ticker dans les actionable_tickers
                for ticker_info in actionable_tickers:
                    # Gestion des objets Pydantic ET des dictionnaires
                    if hasattr(ticker_info, 'ticker'):
                        ticker_value = ticker_info.ticker
                    else:
                        ticker_value = ticker_info.get('ticker', '')
                    
                    if ticker_value in focus_text:
                        ticker = ticker_value
                        break
                
                if ticker:
                    log_step(state, f"üöÄ Analyse PURE PREDICTION pour {ticker} (mode 'tac au tac')")
                    
                    # === MODIFICATION CL√â ICI ===
                    # Utiliser l'agent de pure pr√©diction sans donn√©es de prix
                    analysis = run_pure_prediction_analysis(
                        ticker=ticker,
                        news_summary=state['news_summary'],
                        full_article_text=state['full_article_text']
                    )
                    
                    agent_analyses.append({
                        "agent_type": agent['agent_type'] + "_pure_prediction",  # Marquer le mode
                        "focus": agent['focus'],
                        "analysis": analysis,
                        "ticker": ticker,
                        "is_augmented": False  # Il n'est plus "augment√©" avec des donn√©es de prix
                    })
                    
                    log_step(state, f"‚úÖ Analyse PURE PREDICTION termin√©e pour {ticker}")
                else:
                    # Fallback vers l'analyse classique
                    log_step(state, f"‚ö†Ô∏è Ticker non trouv√©, analyse classique pour {focus_text}")
                    analysis = run_agent_analysis(
                        agent_type=agent['agent_type'],
                        focus=agent['focus'],
                        news_summary=state['news_summary'],
                        full_article_text=state['full_article_text']
                    )
                    
                    agent_analyses.append({
                        "agent_type": agent['agent_type'],
                        "focus": agent['focus'],
                        "analysis": analysis,
                        "is_augmented": False
                    })
                    
                    log_step(state, f"‚úÖ Analyse classique termin√©e: {agent['agent_type']}")
            else:
                # Agent classique (sectoriel, g√©opolitique, etc.)
                log_step(state, f"üìä Analyse classique pour {agent['agent_type']}")
                
                analysis = run_agent_analysis(
                    agent_type=agent['agent_type'],
                    focus=agent['focus'],
                    news_summary=state['news_summary'],
                    full_article_text=state['full_article_text']
                )
                
                agent_analyses.append({
                    "agent_type": agent['agent_type'],
                    "focus": agent['focus'],
                    "analysis": analysis,
                    "is_augmented": False
                })
                
                log_step(state, f"‚úÖ Analyse classique termin√©e: {agent['agent_type']}")
        
        # Formatage du debriefing pour le superviseur
        state['agent_debriefing'] = format_debriefing(agent_analyses)
        
        # Compter les analyses pure prediction
        pure_prediction_count = sum(1 for a in agent_analyses if "pure_prediction" in a.get('agent_type', ''))
        log_step(state, f"‚úÖ Debriefing consolid√© - {len(agent_analyses)} analyses ({pure_prediction_count} pure prediction)")
        
    except Exception as e:
        log_step(state, f"‚ùå ERREUR dans les analyses d'agents: {str(e)}")
        state['agent_debriefing'] = f"ERREUR: {str(e)}"
    
    return state

def node_final_investor_decision(state: GraphState) -> GraphState:
    """N≈ìud 5 : Prend la d√©cision finale d'investissement via l'Agent Superviseur."""
    log_step(state, "D√âCISION - Agent Investisseur Final")
    
    try:
        if not state['agent_debriefing'] or 'ERREUR' in state['agent_debriefing']:
            raise ValueError("Debriefing invalide, impossible de prendre une d√©cision")
        
        # Configuration du parser JSON
        parser = JsonOutputParser(pydantic_object=InvestmentDecision)
        
        # R√©cup√©ration du template de l'investisseur final
        investor_prompt = AGENT_PROFILES["investisseur_final"]
        
        # Formatage des tickers pour l'investisseur final
        actionable_tickers = state.get('actionable_tickers', [])
        tickers_summary = "Aucun ticker sp√©cifique identifi√©"
        
        if actionable_tickers:
            tickers_list = []
            for ticker_info in actionable_tickers:
                # Gestion des objets Pydantic ET des dictionnaires
                if hasattr(ticker_info, 'ticker'):
                    # Objet Pydantic
                    ticker = ticker_info.ticker
                    company = ticker_info.nom_entreprise
                    justification = ticker_info.justification_impact
                else:
                    # Dictionnaire classique (fallback)
                    ticker = ticker_info.get('ticker', 'N/A')
                    company = ticker_info.get('nom_entreprise', 'N/A')
                    justification = ticker_info.get('justification_impact', 'N/A')
                
                tickers_list.append(f"‚Ä¢ {ticker} ({company}): {justification}")
            tickers_summary = "\n".join(tickers_list)
        
        # Cr√©ation de la cha√Æne LangChain
        chain = investor_prompt | llm | parser
        
        # Ex√©cution de la d√©cision
        decision_result = chain.invoke({
            "debriefing_equipe": state['agent_debriefing'],
            "capital_disponible": state['capital_disponible'],
            "actionable_tickers": tickers_summary
        })
        
        # --- D√âBUT DE LA CORRECTION ---
        decision_obj = None
        if isinstance(decision_result, list):
            if decision_result:
                # Si le LLM retourne une liste, on prend le premier √©l√©ment
                log_step(state, "‚ö†Ô∏è  Le LLM a retourn√© une liste, prise du premier √©l√©ment.")
                decision_obj = decision_result[0]
            else:
                raise ValueError("Le LLM a retourn√© une liste vide.")
        else:
            # Comportement normal (objet Pydantic ou dict)
            decision_obj = decision_result
        
        # Maintenant, on s'assure que decision_obj est un dictionnaire
        if hasattr(decision_obj, 'decision'):
            # C'est un objet Pydantic, convertir en dict
            decision_dict = {
                'decision': decision_obj.decision,
                'ticker': decision_obj.ticker,
                'confiance': decision_obj.confiance,
                'justification_synthetique': decision_obj.justification_synthetique,
                'allocation_capital_pourcentage': decision_obj.allocation_capital_pourcentage,
                'points_cles_positifs': decision_obj.points_cles_positifs,
                'points_cles_negatifs_risques': decision_obj.points_cles_negatifs_risques
            }
        else:
            # C'est d√©j√† un dictionnaire
            decision_dict = decision_obj
        # --- FIN DE LA CORRECTION ---

        # --- D√âBUT DE LA CORRECTION LOGIQUE ---
        # Si la d√©cision est d'acheter mais que l'allocation est nulle,
        # la confiance est insuffisante. On ram√®ne la d√©cision √† SURVEILLER.
        if (decision_dict.get('decision') == 'ACHETER' and 
            decision_dict.get('allocation_capital_pourcentage', 0.0) == 0.0):
            
            log_step(state, "‚ö†Ô∏è  INCOH√âRENCE D√âTECT√âE: ACHAT avec 0% d'allocation. D√©cision r√©trograd√©e √† SURVEILLER.")
            
            # R√©trograder la d√©cision
            decision_dict['decision'] = 'SURVEILLER'
            decision_dict['confiance'] = 'FAIBLE' # Forcer la confiance √† FAIBLE
            decision_dict['justification_synthetique'] = f"[R√©trograd√©] Signal d'achat d√©tect√© mais confiance insuffisante pour une allocation de capital. {decision_dict.get('justification_synthetique', '')}"
        # --- FIN DE LA CORRECTION LOGIQUE ---
        
        state['final_decision'] = decision_dict
        
        # Logs d√©taill√©s de la d√©cision
        log_step(state, f"‚úÖ D√âCISION PRISE: {decision_dict.get('decision', 'N/A')}")
        log_step(state, f"   üéØ Ticker: {decision_dict.get('ticker', 'N/A')}")
        log_step(state, f"   üìä Confiance: {decision_dict.get('confiance', 'N/A')}")
        log_step(state, f"   üí∞ Allocation: {decision_dict.get('allocation_capital_pourcentage', 0)}%")
        log_step(state, f"   üìù Justification: {decision_dict.get('justification_synthetique', 'N/A')}")
        
    except Exception as e:
        log_step(state, f"‚ùå ERREUR dans la d√©cision finale: {str(e)}")
        state['final_decision'] = {
            "decision": "ERREUR",
            "ticker": None,
            "confiance": "AUCUNE",
            "justification_synthetique": f"Erreur syst√®me: {str(e)}",
            "allocation_capital_pourcentage": 0.0,
            "points_cles_positifs": [],
            "points_cles_negatifs_risques": ["Erreur syst√®me"]
        }
    
    return state

# --- CONSTRUCTION DU GRAPHE LANGGRAPH ---

def create_workflow() -> StateGraph:
    """Cr√©e et configure le graphe d'orchestration avec le nouveau Ticker Hunter."""
    
    workflow = StateGraph(GraphState)
    
    # Ajout des n≈ìuds (dans l'ordre d'ex√©cution)
    workflow.add_node("initial_analysis", node_initial_analysis)
    workflow.add_node("find_actionable_tickers", node_find_actionable_tickers)  # NOUVEAU
    workflow.add_node("route_to_agents", node_route_to_agents)
    workflow.add_node("run_agent_analyses", node_run_agent_analyses)
    workflow.add_node("final_investor_decision", node_final_investor_decision)
    
    # D√©finition des transitions (nouveau flux avec Ticker Hunter)
    workflow.set_entry_point("initial_analysis")
    workflow.add_edge("initial_analysis", "find_actionable_tickers")  # 1 ‚Üí 2
    workflow.add_edge("find_actionable_tickers", "route_to_agents")   # 2 ‚Üí 3
    workflow.add_edge("route_to_agents", "run_agent_analyses")        # 3 ‚Üí 4
    workflow.add_edge("run_agent_analyses", "final_investor_decision") # 4 ‚Üí 5
    workflow.add_edge("final_investor_decision", END)                 # 5 ‚Üí FIN
    
    return workflow

# --- FONCTION PRINCIPALE D'ORCHESTRATION ---

def run_berzerk_pipeline(news_link: str, capital_disponible: float = 30000.0) -> Dict[str, Any]:
    """
    Ex√©cute le pipeline complet d'analyse BERZERK.
    
    Args:
        news_link: URL de l'article √† analyser
        capital_disponible: Capital disponible pour l'investissement
    
    Returns:
        √âtat final avec la d√©cision d'investissement
    """
    
    print("\n" + "="*80)
    print("üöÄ D√âMARRAGE DU PIPELINE AUTOMATIS√â BERZERK")
    print("="*80)
    
    # √âtat initial
    initial_state = GraphState(
        news_link=news_link,
        news_summary="",
        full_article_text="",
        initial_analysis={},
        actionable_tickers=[],  # NOUVEAU : Pour stocker les tickers identifi√©s
        agent_team=[],
        agent_debriefing="",
        final_decision={},
        capital_disponible=capital_disponible,
        execution_log=[],
        timestamp=datetime.now().isoformat()
    )
    
    # Cr√©ation et compilation du graphe
    workflow = create_workflow()
    app = workflow.compile()
    
    # Ex√©cution du pipeline
    try:
        final_state = app.invoke(initial_state)
        
        print("\n" + "="*80)
        print("üéØ PIPELINE TERMIN√â - R√âSULTATS FINAUX")
        print("="*80)
        
        return final_state
        
    except Exception as e:
        print(f"\n‚ùå ERREUR CRITIQUE DANS LE PIPELINE: {str(e)}")
        return {
            "error": str(e),
            "execution_log": initial_state.get("execution_log", []),
            "final_decision": {
                "decision": "ERREUR_CRITIQUE",
                "justification_synthetique": f"Pipeline interrompu: {str(e)}"
            }
        }

# --- FONCTION D'AFFICHAGE DES R√âSULTATS ---

def display_final_results(final_state: Dict[str, Any]) -> None:
    """Affiche les r√©sultats finaux de mani√®re format√©e."""
    
    # Affichage des tickers identifi√©s
    actionable_tickers = final_state.get('actionable_tickers', [])
    if actionable_tickers:
        print(f"\nüéØ TICKERS IDENTIFI√âS PAR LE TICKER HUNTER:")
        for ticker_info in actionable_tickers:
            # Gestion des objets Pydantic ET des dictionnaires
            if hasattr(ticker_info, 'ticker'):
                ticker = ticker_info.ticker
                company = ticker_info.nom_entreprise
                justification = ticker_info.justification_impact
            else:
                ticker = ticker_info.get('ticker', 'N/A')
                company = ticker_info.get('nom_entreprise', 'N/A')
                justification = ticker_info.get('justification_impact', 'N/A')
            print(f"   üè¢ {ticker} ({company})")
            print(f"      üìù {justification}")
    else:
        print(f"\n‚ö†Ô∏è AUCUN TICKER ACTIONNABLE IDENTIFI√â")
    
    decision = final_state.get('final_decision', {})
    
    print(f"\nüìä D√âCISION FINALE BERZERK:")
    print(f"   üéØ Action: {decision.get('decision', 'N/A')}")
    print(f"   üìà Ticker: {decision.get('ticker', 'N/A')}")
    print(f"   üîí Confiance: {decision.get('confiance', 'N/A')}")
    print(f"   üí∞ Allocation: {decision.get('allocation_capital_pourcentage', 0)}%")
    print(f"   üìù Justification: {decision.get('justification_synthetique', 'N/A')}")
    
    positifs = decision.get('points_cles_positifs', [])
    if positifs:
        print(f"\n‚úÖ Points Positifs:")
        for point in positifs:
            print(f"   ‚Ä¢ {point}")
    
    risques = decision.get('points_cles_negatifs_risques', [])
    if risques:
        print(f"\n‚ö†Ô∏è Risques Identifi√©s:")
        for risque in risques:
            print(f"   ‚Ä¢ {risque}")
    
    print(f"\nüìã Logs d'ex√©cution:")
    for log in final_state.get('execution_log', []):
        print(f"   {log}")

# --- TESTS ET EX√âCUTION PRINCIPALE ---

def test_pipeline():
    """Fonction de test avec des exemples d'articles."""
    
    test_urls = [
        "https://finance.yahoo.com/news/apple-stock-rises-ai-optimism-180000123.html",
        "https://www.reuters.com/technology/artificial-intelligence/",
        "https://finance.yahoo.com/rss/"  # Fallback sur le flux RSS
    ]
    
    print("üß™ MODE TEST - S√©lection automatique d'un article r√©cent")
    
    # Pour le test, on peut utiliser un URL simple ou une simulation
    test_url = "https://finance.yahoo.com/news/"  # URL g√©n√©rique pour test
    
    return run_berzerk_pipeline(
        news_link=test_url,
        capital_disponible=25000.0
    )

if __name__ == "__main__":
    """Point d'entr√©e principal."""
    
    # V√©rification des arguments de ligne de commande
    if len(sys.argv) > 1:
        news_url = sys.argv[1]
        capital = float(sys.argv[2]) if len(sys.argv) > 2 else 30000.0
        
        print(f"üì∞ Analyse de: {news_url}")
        print(f"üí∞ Capital disponible: {capital}‚Ç¨")
        
        final_state = run_berzerk_pipeline(news_url, capital)
        display_final_results(final_state)
        
    else:
        print("üß™ MODE DEMO - Ex√©cution du pipeline de test")
        final_state = test_pipeline()
        display_final_results(final_state)
        
        print("\nüí° Usage: python orchestrator.py <URL_NEWS> [CAPITAL]")
        print("   Exemple: python orchestrator.py 'https://finance.yahoo.com/news/apple-ai-news' 25000") 